import logging
import re
from difflib import SequenceMatcher
from typing import List, Dict, Optional, Tuple
from app.services.services import openai_client, supabase_client
from app.services.memory import add_to_memory, get_conversation_context, get_enhanced_context
from app.utils.text_processing import post_process_answer
from app.services.product_recommendation import hybrid_search_products
from app.config import USE_AGENTIC_RAG

logger = logging.getLogger(__name__)

# Import AgenticRAG (lazy import to avoid circular dependencies)
_agentic_rag = None

def _get_agentic_rag():
    """Lazy import and get AgenticRAG instance"""
    global _agentic_rag
    if _agentic_rag is None and USE_AGENTIC_RAG:
        from app.services.agentic_rag import get_agentic_rag
        _agentic_rag = get_agentic_rag()
    return _agentic_rag

# =============================================================================
# ‡∏Ñ‡∏≥‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏û‡∏∑‡∏ä/‡πÇ‡∏£‡∏Ñ‡∏û‡∏∑‡∏ä/‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡∏©‡∏ï‡∏£
# =============================================================================
AGRICULTURE_KEYWORDS = [
    # ‡∏û‡∏∑‡∏ä
    "‡∏Ç‡πâ‡∏≤‡∏ß", "‡∏ó‡∏∏‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", "‡∏≠‡πâ‡∏≠‡∏¢", "‡∏°‡∏±‡∏ô‡∏™‡∏≥‡∏õ‡∏∞‡∏´‡∏•‡∏±‡∏á", "‡∏°‡∏±‡∏ô‡∏™‡∏±‡∏°‡∏õ‡∏∞‡∏´‡∏•‡∏±‡∏á", "‡∏¢‡∏≤‡∏á‡∏û‡∏≤‡∏£‡∏≤", "‡∏õ‡∏≤‡∏•‡πå‡∏°",
    "‡∏°‡∏∞‡∏°‡πà‡∏ß‡∏á", "‡∏•‡∏≥‡πÑ‡∏¢", "‡∏•‡∏¥‡πâ‡∏ô‡∏à‡∏µ‡πà", "‡πÄ‡∏á‡∏≤‡∏∞", "‡∏°‡∏±‡∏á‡∏Ñ‡∏∏‡∏î", "‡∏û‡∏£‡∏¥‡∏Å", "‡∏°‡∏∞‡πÄ‡∏Ç‡∏∑‡∏≠‡πÄ‡∏ó‡∏®", "‡∏Ç‡πâ‡∏≤‡∏ß‡πÇ‡∏û‡∏î",
    "‡∏ñ‡∏±‡πà‡∏ß", "‡∏ú‡∏±‡∏Å", "‡∏ú‡∏•‡πÑ‡∏°‡πâ", "‡∏Å‡∏•‡πâ‡∏ß‡∏¢", "‡∏°‡∏∞‡∏û‡∏£‡πâ‡∏≤‡∏ß", "‡∏™‡πâ‡∏°", "‡∏°‡∏∞‡∏ô‡∏≤‡∏ß", "‡∏ù‡∏£‡∏±‡πà‡∏á", "‡∏ä‡∏°‡∏û‡∏π‡πà",
    # ‡πÇ‡∏£‡∏Ñ/‡∏õ‡∏±‡∏ç‡∏´‡∏≤
    "‡πÇ‡∏£‡∏Ñ", "‡πÇ‡∏£‡∏Ñ‡∏û‡∏∑‡∏ä", "‡πÉ‡∏ö‡πÑ‡∏´‡∏°‡πâ", "‡πÉ‡∏ö‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á", "‡πÉ‡∏ö‡∏à‡∏∏‡∏î", "‡∏£‡∏≤‡∏Å‡πÄ‡∏ô‡πà‡∏≤", "‡πÇ‡∏Ñ‡∏ô‡πÄ‡∏ô‡πà‡∏≤", "‡∏ú‡∏•‡πÄ‡∏ô‡πà‡∏≤",
    "‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤", "‡πÅ‡∏ö‡∏Ñ‡∏ó‡∏µ‡πÄ‡∏£‡∏µ‡∏¢", "‡πÑ‡∏ß‡∏£‡∏±‡∏™", "‡πÅ‡∏°‡∏•‡∏á", "‡πÄ‡∏û‡∏•‡∏µ‡πâ‡∏¢", "‡∏´‡∏ô‡∏≠‡∏ô", "‡∏î‡πâ‡∏ß‡∏á", "‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏û‡∏∑‡∏ä",
    "‡∏£‡∏≤‡∏ô‡πâ‡∏≥‡∏Ñ‡πâ‡∏≤‡∏á", "‡∏£‡∏≤‡πÅ‡∏õ‡πâ‡∏á", "‡∏£‡∏≤‡∏™‡∏ô‡∏¥‡∏°", "‡πÅ‡∏≠‡∏ô‡πÅ‡∏ó‡∏£‡∏Ñ‡πÇ‡∏ô‡∏™", "‡∏Å‡∏¥‡πà‡∏á‡πÅ‡∏´‡πâ‡∏á", "‡∏•‡∏≥‡∏ï‡πâ‡∏ô‡πÄ‡∏ô‡πà‡∏≤",
    # ‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡∏©‡∏ï‡∏£‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
    "‡∏£‡∏∞‡∏¢‡∏∞", "‡∏ä‡πà‡∏ß‡∏á", "‡∏õ‡∏•‡∏π‡∏Å", "‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß", "‡∏î‡∏π‡πÅ‡∏•", "‡∏ö‡∏≥‡∏£‡∏∏‡∏á", "‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á", "‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô",
    "‡∏≠‡∏≤‡∏Å‡∏≤‡∏£", "‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏", "‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏Å‡∏©‡∏≤", "‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ", "‡∏ß‡∏¥‡∏ò‡∏µ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô"
]


def is_agriculture_question(message: str) -> bool:
    """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡∏©‡∏ï‡∏£/‡∏û‡∏∑‡∏ä/‡πÇ‡∏£‡∏Ñ‡∏û‡∏∑‡∏ä‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
    message_lower = message.lower()
    for keyword in AGRICULTURE_KEYWORDS:
        if keyword in message_lower:
            return True
    return False


# =============================================================================
# Keywords ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤/‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå
# =============================================================================
PRODUCT_KEYWORDS = [
    "‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤", "‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå", "‡∏¢‡∏≤", "‡∏¢‡∏≤‡∏Ü‡πà‡∏≤", "‡∏¢‡∏≤‡∏Å‡∏≥‡∏à‡∏±‡∏î", "‡∏¢‡∏≤‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô",
    "‡∏¢‡∏≤‡∏Ü‡πà‡∏≤‡πÅ‡∏°‡∏•‡∏á", "‡∏¢‡∏≤‡∏Ü‡πà‡∏≤‡∏´‡∏ç‡πâ‡∏≤", "‡∏¢‡∏≤‡∏Ü‡πà‡∏≤‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤", "‡∏õ‡∏∏‡πã‡∏¢", "‡∏Æ‡∏≠‡∏£‡πå‡πÇ‡∏°‡∏ô",
    "‡∏™‡∏≤‡∏£‡πÄ‡∏Ñ‡∏°‡∏µ", "‡∏™‡∏≤‡∏£‡∏Å‡∏≥‡∏à‡∏±‡∏î", "‡∏™‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô", "‡∏¢‡∏≤‡∏û‡πà‡∏ô", "‡∏¢‡∏≤‡∏â‡∏µ‡∏î",
    "‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏¢‡∏≤", "‡πÉ‡∏ä‡πâ‡∏¢‡∏≤‡∏≠‡∏∞‡πÑ‡∏£", "‡∏¢‡∏≤‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô", "‡∏¢‡∏≤‡∏≠‡∏∞‡πÑ‡∏£‡∏î‡∏µ",
    "icp", "ladda", "‡πÑ‡∏≠‡∏ã‡∏µ‡∏û‡∏µ", "‡∏•‡∏±‡∏î‡∏î‡∏≤"
]

# =============================================================================
# ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ICP Ladda (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏¢‡∏≤‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°)
# =============================================================================
ICP_PRODUCT_NAMES = {
    # ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏ï‡πá‡∏° -> ‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ú‡∏¥‡∏î/‡∏¢‡πà‡∏≠)
    "‡∏Å‡∏∞‡∏£‡∏±‡∏ï": ["‡∏Å‡∏∞‡∏£‡∏±‡∏ï", "‡∏Å‡∏∞‡∏£‡∏±‡∏ï 35"],
    "‡∏Å‡πá‡∏≠‡∏õ‡∏Å‡∏±‡∏ô": ["‡∏Å‡πá‡∏≠‡∏õ‡∏Å‡∏±‡∏ô", "‡∏Å‡∏≠‡∏õ‡∏Å‡∏±‡∏ô", "‡∏ó‡πá‡∏≠‡∏õ‡∏Å‡∏±‡∏ô", "‡∏ó‡∏≠‡∏õ‡∏Å‡∏±‡∏ô"],
    "‡∏Ñ‡∏≤‡∏£‡∏¥‡∏™‡∏°‡∏≤": ["‡∏Ñ‡∏≤‡∏£‡∏¥‡∏™‡∏°‡∏≤", "‡∏Ñ‡∏≤‡∏£‡∏¥‡∏™‡∏°‡πà‡∏≤", "‡∏Ñ‡∏≤‡∏£‡∏¥‡∏™"],
    "‡∏ã‡∏¥‡∏°‡πÄ‡∏°‡∏≠‡∏£‡πå": ["‡∏ã‡∏¥‡∏°‡πÄ‡∏°‡∏≠‡∏£‡πå", "‡∏ã‡∏¥‡∏°‡πÄ‡∏°‡∏≠"],
    "‡∏ã‡∏µ‡πÄ‡∏≠‡πá‡∏°‡∏à‡∏µ": ["‡∏ã‡∏µ‡πÄ‡∏≠‡πá‡∏°‡∏à‡∏µ", "cmg", "‡∏ã‡∏µ‡πÄ‡∏≠‡∏°‡∏à‡∏µ"],
    "‡∏ó‡∏π‡πÇ‡∏ü‡∏ü‡∏≠‡∏™": ["‡∏ó‡∏π‡πÇ‡∏ü‡∏ü‡∏≠‡∏™", "‡∏ó‡∏π‡πÇ‡∏ü", "‡∏ó‡∏π‡πÇ‡∏ü‡πÇ‡∏ü‡∏™"],
    "‡∏ô‡∏≤‡πÅ‡∏î‡∏ô": ["‡∏ô‡∏≤‡πÅ‡∏î‡∏ô", "‡∏ô‡∏≤‡πÅ‡∏î‡∏ô 6 ‡∏à‡∏µ", "‡∏ô‡∏≤‡πÅ‡∏î‡∏ô-‡∏à‡∏µ"],
    "‡∏ö‡∏•‡∏π‡πÑ‡∏ß‡∏ó‡πå": ["‡∏ö‡∏•‡∏π‡πÑ‡∏ß‡∏ó‡πå", "‡∏ö‡∏•‡∏π‡πÑ‡∏ß‡∏ï‡πå"],
    "‡∏û‡∏£‡∏µ‡∏î‡∏¥‡∏Ñ‡∏ó‡πå": ["‡∏û‡∏£‡∏µ‡∏î‡∏¥‡∏Ñ‡∏ó‡πå", "‡∏û‡∏£‡∏µ‡∏î‡∏¥‡∏Ñ", "predict"],
    "‡∏û‡∏≤‡∏™‡∏ô‡∏≤‡∏ß": ["‡∏û‡∏≤‡∏™‡∏ô‡∏≤‡∏ß", "‡∏û‡∏≤‡∏™‡∏ô‡∏≤‡∏ß‡πå"],
    "‡∏û‡∏≤‡∏ô‡∏≤‡∏™": ["‡∏û‡∏≤‡∏ô‡∏≤‡∏™", "‡πÄ‡∏•‡∏Å‡∏≤‡∏ã‡∏µ 20 + ‡∏û‡∏≤‡∏ô‡∏≤‡∏™"],
    "‡∏£‡∏≤‡πÄ‡∏ã‡∏≠‡∏£‡πå": ["‡∏£‡∏≤‡πÄ‡∏ã‡∏≠‡∏£‡πå", "‡πÄ‡∏£‡πÄ‡∏ã‡∏≠‡∏£‡πå"],
    "‡∏£‡∏µ‡πÇ‡∏ô‡πÄ‡∏ß‡∏ó": ["‡∏£‡∏µ‡πÇ‡∏ô‡πÄ‡∏ß‡∏ó", "‡∏£‡∏µ‡πÇ‡∏ô‡πÄ‡∏ß‡∏ï", "renovate"],
    "‡∏ß‡∏≠‡∏£‡πå‡πÅ‡∏£‡∏ô‡∏ï‡πå": ["‡∏ß‡∏≠‡∏£‡πå‡πÅ‡∏£‡∏ô‡∏ï‡πå", "‡∏ß‡∏≠‡πÅ‡∏£‡∏ô‡∏ï‡πå", "warrant"],
    "‡∏≠‡∏∞‡∏ô‡∏¥‡∏•‡∏Å‡∏≤‡∏£‡πå‡∏î": ["‡∏≠‡∏∞‡∏ô‡∏¥‡∏•‡∏Å‡∏≤‡∏£‡πå‡∏î", "‡∏≠‡∏ô‡∏¥‡∏•‡∏Å‡∏≤‡∏£‡πå‡∏î"],
    "‡∏≠‡∏±‡∏û‡∏î‡∏≤‡∏ß": ["‡∏≠‡∏±‡∏û‡∏î‡∏≤‡∏ß", "‡∏≠‡∏±‡∏õ‡∏î‡∏≤‡∏ß"],
    "‡∏≠‡∏≤‡∏£‡πå‡∏î‡∏≠‡∏ô": ["‡∏≠‡∏≤‡∏£‡πå‡∏î‡∏≠‡∏ô", "‡∏≠‡∏≤‡∏î‡∏≠‡∏ô"],
    "‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏ó‡∏°‡∏µ‡∏™": ["‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏ó‡∏°‡∏µ‡∏™", "‡∏≠‡∏≤‡πÄ‡∏ó‡∏°‡∏¥‡∏™", "‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏ó‡∏°‡∏¥‡∏™", "artemis"],
    "‡∏≠‡∏¥‡∏°‡∏¥‡∏î‡∏≤‡πÇ‡∏Å‡∏•‡∏î‡πå": ["‡∏≠‡∏¥‡∏°‡∏¥‡∏î‡∏≤‡πÇ‡∏Å‡∏•‡∏î‡πå", "‡∏≠‡∏¥‡∏°‡∏¥‡∏î‡∏≤", "‡∏≠‡∏¥‡∏°‡∏¥‡∏î‡∏≤‡πÇ‡∏Å‡∏•", "imidagold", "‡∏≠‡∏¥‡∏°‡∏¥‡∏î‡∏≤‡πÇ‡∏Å‡∏•‡∏î‡πå70", "‡∏≠‡∏¥‡∏°‡∏¥‡∏î‡∏≤‡πÇ‡∏Å‡∏•‡∏î‡πå 70"],
    "‡πÄ‡∏Å‡∏£‡∏Ñ": ["‡πÄ‡∏Å‡∏£‡∏Ñ", "‡πÄ‡∏Å‡∏£‡∏Ñ 5 ‡πÄ‡∏≠‡∏™‡∏ã‡∏µ", "‡πÄ‡∏Å‡∏£‡∏î", "‡πÄ‡∏Å‡∏£‡∏î5", "‡πÄ‡∏Å‡∏£‡∏Ñ5", "‡πÄ‡∏Å‡∏£‡∏î 5"],
    "‡πÄ‡∏Ñ‡πÄ‡∏ã‡∏µ‡∏¢": ["‡πÄ‡∏Ñ‡πÄ‡∏ã‡∏µ‡∏¢", "‡πÄ‡∏Ñ‡πÄ‡∏ã‡∏µ‡∏¢‡πå"],
    "‡πÄ‡∏ó‡∏≠‡∏£‡∏≤‡πÇ‡∏ô‡πà": ["‡πÄ‡∏ó‡∏≠‡∏£‡∏≤‡πÇ‡∏ô‡πà", "‡πÄ‡∏ó‡∏≠‡∏£‡∏≤‡πÇ‡∏ô", "terano"],
    "‡πÄ‡∏ö‡∏ô‡∏ã‡∏≤‡∏ô‡πà‡∏≤": ["‡πÄ‡∏ö‡∏ô‡∏ã‡∏≤‡∏ô‡πà‡∏≤", "‡πÄ‡∏ö‡∏ô‡∏ã‡∏≤‡∏ô‡πà‡∏≤ ‡πÄ‡∏≠‡∏ü"],
    "‡πÄ‡∏°‡∏•‡∏™‡∏±‡∏ô": ["‡πÄ‡∏°‡∏•‡∏™‡∏±‡∏ô", "‡πÄ‡∏°‡∏•‡∏ã‡∏±‡∏ô"],
    "‡πÅ‡∏Å‡∏ô‡πÄ‡∏ï‡∏≠‡∏£‡πå": ["‡πÅ‡∏Å‡∏ô‡πÄ‡∏ï‡∏≠‡∏£‡πå", "‡πÅ‡∏Å‡∏ô‡πÄ‡∏ï‡∏≠", "‡πÅ‡∏Å‡∏ô‡πÄ‡∏ï‡∏≠‡∏£"],
    "‡πÅ‡∏à‡πä‡∏™": ["‡πÅ‡∏à‡πä‡∏™", "‡πÅ‡∏à‡∏™", "jazz"],
    "‡πÅ‡∏°‡∏™‡∏ü‡∏≠‡∏£‡πå‡∏î": ["‡πÅ‡∏°‡∏™‡∏ü‡∏≠‡∏£‡πå‡∏î", "‡πÅ‡∏°‡∏™‡∏ü‡∏≠‡∏î"],
    "‡πÅ‡∏≠‡∏ô‡∏î‡∏≤‡πÅ‡∏°‡πá‡∏Å‡∏ã‡πå": ["‡πÅ‡∏≠‡∏ô‡∏î‡∏≤‡πÅ‡∏°‡πá‡∏Å‡∏ã‡πå", "‡πÅ‡∏≠‡∏ô‡∏î‡∏≤‡πÅ‡∏°‡∏Å‡∏ã‡πå", "‡πÅ‡∏≠‡∏ô‡∏î‡∏≤‡πÅ‡∏°‡πá‡∏Å", "andamax"],
    "‡πÅ‡∏≠‡∏™‡πÑ‡∏õ‡∏£‡πå": ["‡πÅ‡∏≠‡∏™‡πÑ‡∏õ‡∏£‡πå", "‡πÅ‡∏≠‡∏™‡πÑ‡∏õ‡∏£", "aspire"],
    "‡πÇ‡∏Ñ-‡∏£‡∏≤‡∏ã": ["‡πÇ‡∏Ñ-‡∏£‡∏≤‡∏ã", "‡πÇ‡∏Ñ‡∏£‡∏≤‡∏ã"],
    "‡πÇ‡∏Ñ‡πÄ‡∏ö‡∏¥‡∏•": ["‡πÇ‡∏Ñ‡πÄ‡∏ö‡∏¥‡∏•", "‡πÇ‡∏Ñ‡πÄ‡∏ö‡∏¥‡πâ‡∏•"],
    "‡πÇ‡∏ã‡∏ô‡∏¥‡∏Å": ["‡πÇ‡∏ã‡∏ô‡∏¥‡∏Å", "sonic"],
    "‡πÇ‡∏ó‡∏°‡∏≤‡∏Æ‡∏≠‡∏Ñ": ["‡πÇ‡∏ó‡∏°‡∏≤‡∏Æ‡∏≠‡∏Ñ", "‡πÇ‡∏ó‡∏°‡∏≤‡∏Æ‡∏≠‡∏Å", "tomahawk"],
    "‡πÇ‡∏°-‡πÄ‡∏ã‡πà": ["‡πÇ‡∏°-‡πÄ‡∏ã‡πà", "‡πÇ‡∏°‡πÄ‡∏ã‡πà", "‡πÇ‡∏°‡πÄ‡∏ã"],
    "‡πÇ‡∏°‡πÄ‡∏î‡∏¥‡∏ô": ["‡πÇ‡∏°‡πÄ‡∏î‡∏¥‡∏ô", "‡πÇ‡∏°‡πÄ‡∏î‡∏¥‡∏ô 50", "‡πÇ‡∏°‡πÄ‡∏î‡∏¥‡∏ô50"],
    "‡πÇ‡∏Æ‡∏õ": ["‡πÇ‡∏Æ‡∏õ", "hope"],
    "‡πÑ‡∏ã‡∏°‡πä‡∏≠‡∏Å‡∏ã‡∏¥‡πÄ‡∏°‡∏ó": ["‡πÑ‡∏ã‡∏°‡πä‡∏≠‡∏Å‡∏ã‡∏¥‡πÄ‡∏°‡∏ó", "‡πÑ‡∏ã‡∏°‡∏≠‡∏Å‡∏ã‡∏¥‡πÄ‡∏°‡∏ó", "cymoximate"],
    "‡πÑ‡∏î‡πÅ‡∏û‡πä‡∏Å‡∏ã‡πå": ["‡πÑ‡∏î‡πÅ‡∏û‡πä‡∏Å‡∏ã‡πå", "‡πÑ‡∏î‡πÅ‡∏û‡∏Å‡∏ã‡πå"],
    "‡πÑ‡∏û‡∏£‡∏ã‡∏µ‡∏ô": ["‡πÑ‡∏û‡∏£‡∏ã‡∏µ‡∏ô", "‡πÑ‡∏û‡∏£‡∏ã‡∏¥‡∏ô"],
    "‡πÑ‡∏Æ‡∏ã‡∏µ‡∏™": ["‡πÑ‡∏Æ‡∏ã‡∏µ‡∏™", "‡πÑ‡∏Æ‡∏ã‡∏¥‡∏™", "hysis"],
    "‡∏ä‡∏∏‡∏î‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏°‡πà‡∏ß‡∏á": ["‡∏ä‡∏∏‡∏î‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏°‡πà‡∏ß‡∏á", "‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏°‡πà‡∏ß‡∏á"],
    "‡πÄ‡∏•‡∏Å‡∏≤‡∏ã‡∏µ": ["‡πÄ‡∏•‡∏Å‡∏≤‡∏ã‡∏µ", "legacy"],
}


def extract_product_name_from_question(question: str) -> Optional[str]:
    """
    ‡∏î‡∏∂‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°
    Returns: ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏û‡∏ö ‡∏´‡∏£‡∏∑‡∏≠ None ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö
    """
    question_lower = question.lower()

    # Step 1: Exact substring match (‡πÄ‡∏£‡πá‡∏ß)
    for product_name, aliases in ICP_PRODUCT_NAMES.items():
        for alias in aliases:
            if alias.lower() in question_lower:
                return product_name

    # Step 2: Fuzzy match (fallback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ú‡∏¥‡∏î)
    return fuzzy_match_product_name(question)


def fuzzy_match_product_name(text: str, threshold: float = 0.65) -> Optional[str]:
    """
    Fuzzy matching ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ú‡∏¥‡∏î
    ‡πÄ‡∏ä‡πà‡∏ô "‡πÅ‡πÅ‡∏Å‡∏ô‡πÄ‡∏ï‡∏≠" ‚Üí "‡πÅ‡∏Å‡∏ô‡πÄ‡∏ï‡∏≠‡∏£‡πå", "‡πÇ‡∏°‡πÄ‡∏î‡∏¥‡πâ‡∏ô" ‚Üí "‡πÇ‡∏°‡πÄ‡∏î‡∏¥‡∏ô"
    """
    # ‡πÅ‡∏¢‡∏Å‡∏Ñ‡∏≥: ‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏≥‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥ English
    tokens = re.findall(r'[\u0E00-\u0E7F]+|[a-zA-Z]+', text)

    best_match = None
    best_score = 0.0

    for token in tokens:
        if len(token) < 3:  # ‡∏Ç‡πâ‡∏≤‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πâ‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
            continue
        token_lower = token.lower()
        for product_name, aliases in ICP_PRODUCT_NAMES.items():
            for alias in aliases:
                alias_lower = alias.lower()
                # Direct comparison
                score = SequenceMatcher(None, token_lower, alias_lower).ratio()
                if score > best_score and score >= threshold:
                    best_score = score
                    best_match = product_name

                # Sliding window: ‡∏ñ‡πâ‡∏≤ token ‡∏¢‡∏≤‡∏ß‡∏Å‡∏ß‡πà‡∏≤ alias ‡∏°‡∏≤‡∏Å ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö substring
                alias_len = len(alias_lower)
                if len(token_lower) > alias_len + 1 and alias_len >= 3:
                    for i in range(len(token_lower) - alias_len + 2):
                        end = min(i + alias_len + 1, len(token_lower))
                        sub = token_lower[i:end]
                        score = SequenceMatcher(None, sub, alias_lower).ratio()
                        if score > best_score and score >= threshold:
                            best_score = score
                            best_match = product_name

    return best_match


def detect_unknown_product_in_question(question: str) -> Optional[str]:
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ user ‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏ô ICP_PRODUCT_NAMES ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    Returns: ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å ‡∏´‡∏£‡∏∑‡∏≠ None

    ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà user ‡∏ñ‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á ‡πÄ‡∏ä‡πà‡∏ô "‡πÇ‡∏ï‡πÇ‡∏£‡πà ‡πÉ‡∏ä‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏á"
    ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ ‡πÄ‡∏ä‡πà‡∏ô "‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏¢‡∏≤‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô"
    """
    # ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß ‚Üí return None
    if extract_product_name_from_question(question):
        return None

    # ‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡πâ‡∏≤‡∏° (‡∏Ñ‡∏≥‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ, ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°, ‡∏Ñ‡∏≥‡∏Å‡∏£‡∏¥‡∏¢‡∏≤)
    skip_words = [
        '‡∏≠‡∏∞‡πÑ‡∏£', '‡∏¢‡∏±‡∏á‡πÑ‡∏á', '‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£', '‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà', '‡∏ï‡∏±‡∏ß‡πÑ‡∏´‡∏ô', '‡∏Å‡∏µ‡πà', '‡∏ó‡∏≥‡πÑ‡∏°', '‡πÑ‡∏´‡∏°',
        '‡πÉ‡∏ä‡πâ', '‡∏û‡πà‡∏ô', '‡∏â‡∏µ‡∏î', '‡∏ú‡∏™‡∏°', '‡∏Å‡∏≥‡∏à‡∏±‡∏î', '‡∏£‡∏±‡∏Å‡∏©‡∏≤', '‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥', '‡∏î‡∏µ', '‡πÑ‡∏î‡πâ',
        '‡∏¢‡∏≤', '‡∏™‡∏≤‡∏£', '‡πÇ‡∏£‡∏Ñ', '‡πÅ‡∏°‡∏•‡∏á', '‡∏´‡∏ç‡πâ‡∏≤', '‡∏ß‡∏±‡∏ä‡∏û‡∏∑‡∏ä', '‡∏ò‡∏≤‡∏ï‡∏∏', '‡∏≠‡∏≤‡∏´‡∏≤‡∏£',
        '‡∏Ç‡πâ‡∏≤‡∏ß', '‡∏ó‡∏∏‡πÄ‡∏£‡∏µ‡∏¢‡∏ô', '‡∏°‡∏∞‡∏°‡πà‡∏ß‡∏á', '‡∏™‡πâ‡∏°', '‡∏û‡∏£‡∏¥‡∏Å', '‡∏Ç‡πâ‡∏≤‡∏ß‡πÇ‡∏û‡∏î', '‡∏≠‡πâ‡∏≠‡∏¢',
        '‡∏ô‡∏≤', '‡πÑ‡∏£‡πà', '‡∏™‡∏ß‡∏ô', '‡∏ï‡πâ‡∏ô', '‡πÉ‡∏ö', '‡∏ú‡∏•', '‡∏î‡∏≠‡∏Å',
        '‡∏Ü‡πà‡∏≤', '‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô', '‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°', '‡∏Ç‡∏≤‡∏î', '‡∏£‡πà‡∏ß‡∏á', '‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á', '‡∏à‡∏∏‡∏î',
        '‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç', '‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î', '‡∏ö‡∏≥‡∏£‡∏∏‡∏á', '‡∏ï‡∏¥‡∏î', '‡∏Å‡∏≤‡∏£'
    ]

    # pattern ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å
    # ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏£‡∏ì‡∏µ "XXX ‡πÉ‡∏ä‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏á" ‡∏ó‡∏µ‡πà XXX ‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
    import re

    # Pattern 1: "XXX ‡πÉ‡∏ä‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏á" - XXX ‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ
    match = re.match(r'^([‡∏Å-‡πôa-zA-Z]+)\s+(?:‡πÉ‡∏ä‡πâ|‡∏û‡πà‡∏ô|‡∏â‡∏µ‡∏î|‡∏ú‡∏™‡∏°)', question.strip())
    if match:
        potential_product = match.group(1)
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Ñ‡∏≥‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        if potential_product.lower() not in [w.lower() for w in skip_words]:
            if 2 < len(potential_product) < 20:
                return potential_product

    return None


def extract_plant_type_from_question(question: str) -> Optional[str]:
    """
    ‡∏î‡∏∂‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏û‡∏∑‡∏ä‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°
    Returns: ‡∏ä‡∏∑‡πà‡∏≠‡∏û‡∏∑‡∏ä ‡∏´‡∏£‡∏∑‡∏≠ None ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö
    """
    # ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏û‡∏∑‡∏ä‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
    plants = [
        "‡∏ó‡∏∏‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", "‡∏Ç‡πâ‡∏≤‡∏ß", "‡∏Ç‡πâ‡∏≤‡∏ß‡πÇ‡∏û‡∏î", "‡∏°‡∏±‡∏ô‡∏™‡∏≥‡∏õ‡∏∞‡∏´‡∏•‡∏±‡∏á", "‡∏≠‡πâ‡∏≠‡∏¢", "‡∏¢‡∏≤‡∏á‡∏û‡∏≤‡∏£‡∏≤", "‡∏õ‡∏≤‡∏•‡πå‡∏°",
        "‡∏°‡∏∞‡∏°‡πà‡∏ß‡∏á", "‡∏•‡∏≥‡πÑ‡∏¢", "‡∏•‡∏¥‡πâ‡∏ô‡∏à‡∏µ‡πà", "‡πÄ‡∏á‡∏≤‡∏∞", "‡∏°‡∏±‡∏á‡∏Ñ‡∏∏‡∏î", "‡∏û‡∏£‡∏¥‡∏Å", "‡∏°‡∏∞‡πÄ‡∏Ç‡∏∑‡∏≠‡πÄ‡∏ó‡∏®",
        "‡∏ñ‡∏±‡πà‡∏ß", "‡∏Å‡∏•‡πâ‡∏ß‡∏¢", "‡∏°‡∏∞‡∏û‡∏£‡πâ‡∏≤‡∏ß", "‡∏™‡πâ‡∏°", "‡∏°‡∏∞‡∏ô‡∏≤‡∏ß", "‡∏ù‡∏£‡∏±‡πà‡∏á", "‡∏ä‡∏°‡∏û‡∏π‡πà",
        "‡∏™‡∏±‡∏ö‡∏õ‡∏∞‡∏£‡∏î", "‡∏´‡∏≠‡∏°‡πÅ‡∏î‡∏á", "‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°", "‡∏ú‡∏±‡∏Å", "‡πÑ‡∏°‡πâ‡∏ú‡∏•"
    ]

    question_lower = question.lower()
    for plant in plants:
        if plant in question_lower:
            return plant
    return None


def is_product_question(message: str) -> bool:
    """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤/‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
    message_lower = message.lower()
    for keyword in PRODUCT_KEYWORDS:
        if keyword in message_lower:
            return True
    return False


# =============================================================================
# ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏õ‡∏±‡∏ç‡∏´‡∏≤: ‡πÇ‡∏£‡∏Ñ vs ‡πÅ‡∏°‡∏•‡∏á vs ‡∏ò‡∏≤‡∏ï‡∏∏‡∏≠‡∏≤‡∏´‡∏≤‡∏£ vs ‡∏ß‡∏±‡∏ä‡∏û‡∏∑‡∏ä
# =============================================================================
DISEASE_KEYWORDS = [
    # ‡πÇ‡∏£‡∏Ñ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
    "‡πÇ‡∏£‡∏Ñ", "‡πÉ‡∏ö‡∏à‡∏∏‡∏î", "‡πÉ‡∏ö‡πÑ‡∏´‡∏°‡πâ", "‡∏£‡∏≤‡∏ô‡πâ‡∏≥‡∏Ñ‡πâ‡∏≤‡∏á", "‡∏£‡∏≤‡πÅ‡∏õ‡πâ‡∏á", "‡∏£‡∏≤‡∏™‡∏ô‡∏¥‡∏°", "‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤",
    "‡πÅ‡∏≠‡∏ô‡πÅ‡∏ó‡∏£‡∏Ñ‡πÇ‡∏ô‡∏™", "‡∏ú‡∏•‡πÄ‡∏ô‡πà‡∏≤", "‡∏£‡∏≤‡∏Å‡πÄ‡∏ô‡πà‡∏≤", "‡πÇ‡∏Ñ‡∏ô‡πÄ‡∏ô‡πà‡∏≤", "‡∏•‡∏≥‡∏ï‡πâ‡∏ô‡πÄ‡∏ô‡πà‡∏≤", "‡∏Å‡∏¥‡πà‡∏á‡πÅ‡∏´‡πâ‡∏á",
    "‡∏£‡∏≤‡∏î‡∏≥", "‡∏à‡∏∏‡∏î‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•", "‡πÉ‡∏ö‡πÅ‡∏´‡πâ‡∏á", "‡πÑ‡∏ü‡∏ó‡πá‡∏≠‡∏õ", "‡πÉ‡∏ö‡∏ï‡∏¥‡∏î",
    # English
    "disease", "fungus", "fungal", "rot", "blight", "mildew", "rust", "anthracnose"
]

INSECT_KEYWORDS = [
    # ‡πÅ‡∏°‡∏•‡∏á (‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á "‡πÑ‡∏£" ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏à‡∏∞ match ‡∏Å‡∏±‡∏ö "‡∏≠‡∏∞‡πÑ‡∏£")
    "‡πÅ‡∏°‡∏•‡∏á", "‡πÄ‡∏û‡∏•‡∏µ‡πâ‡∏¢", "‡∏´‡∏ô‡∏≠‡∏ô", "‡∏î‡πâ‡∏ß‡∏á", "‡∏°‡∏î", "‡∏õ‡∏•‡∏ß‡∏Å", "‡πÄ‡∏û‡∏•‡∏µ‡πâ‡∏¢‡πÑ‡∏ü",
    "‡πÄ‡∏û‡∏•‡∏µ‡πâ‡∏¢‡∏≠‡πà‡∏≠‡∏ô", "‡πÄ‡∏û‡∏•‡∏µ‡πâ‡∏¢‡πÅ‡∏õ‡πâ‡∏á", "‡πÄ‡∏û‡∏•‡∏µ‡πâ‡∏¢‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î", "‡∏´‡∏ô‡∏≠‡∏ô‡∏Å‡∏≠", "‡∏´‡∏ô‡∏≠‡∏ô‡πÄ‡∏à‡∏≤‡∏∞",
    "‡∏´‡∏ô‡∏≠‡∏ô‡πÉ‡∏¢", "‡πÅ‡∏°‡∏•‡∏á‡∏ß‡∏±‡∏ô", "‡∏à‡∏±‡∏Å‡∏à‡∏±‡πà‡∏ô", "‡∏ó‡∏£‡∏¥‡∏õ‡∏™‡πå", "‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏û‡∏∑‡∏ä",
    "‡πÑ‡∏£‡πÅ‡∏î‡∏á", "‡πÑ‡∏£‡∏Ç‡∏≤‡∏ß", "‡πÑ‡∏£‡πÅ‡∏°‡∏á", "‡∏ï‡∏±‡∏ß‡πÑ‡∏£",
    # English
    "insect", "pest", "aphid", "thrips", "mite", "worm", "caterpillar", "beetle"
]

# ‡πÄ‡∏û‡∏¥‡πà‡∏°: Keywords ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ò‡∏≤‡∏ï‡∏∏‡∏≠‡∏≤‡∏´‡∏≤‡∏£/‡∏Å‡∏≤‡∏£‡∏ö‡∏≥‡∏£‡∏∏‡∏á
NUTRIENT_KEYWORDS = [
    # ‡∏Ç‡∏≤‡∏î‡∏ò‡∏≤‡∏ï‡∏∏/‡∏ö‡∏≥‡∏£‡∏∏‡∏á
    "‡∏Ç‡∏≤‡∏î‡∏ò‡∏≤‡∏ï‡∏∏", "‡∏ò‡∏≤‡∏ï‡∏∏‡∏≠‡∏≤‡∏´‡∏≤‡∏£", "‡∏ö‡∏≥‡∏£‡∏∏‡∏á", "‡πÄ‡∏™‡∏£‡∏¥‡∏°‡∏ò‡∏≤‡∏ï‡∏∏", "‡∏õ‡∏∏‡πã‡∏¢",
    # ‡∏≠‡∏≤‡∏Å‡∏≤‡∏£
    "‡∏î‡∏≠‡∏Å‡∏£‡πà‡∏ß‡∏á", "‡∏ú‡∏•‡∏£‡πà‡∏ß‡∏á", "‡πÉ‡∏ö‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á", "‡πÉ‡∏ö‡∏£‡πà‡∏ß‡∏á", "‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î‡∏î‡∏≠‡∏Å", "‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î‡∏ú‡∏•",
    "‡∏î‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î", "‡∏ú‡∏•‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î", "‡∏ï‡πâ‡∏ô‡πÇ‡∏ó‡∏£‡∏°", "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå",
    # ‡∏Å‡∏≤‡∏£‡∏ö‡∏≥‡∏£‡∏∏‡∏á
    "‡∏ï‡∏¥‡∏î‡∏î‡∏≠‡∏Å", "‡∏ï‡∏¥‡∏î‡∏ú‡∏•", "‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ú‡∏•", "‡∏ö‡∏≥‡∏£‡∏∏‡∏á‡∏î‡∏≠‡∏Å", "‡∏ö‡∏≥‡∏£‡∏∏‡∏á‡∏ú‡∏•", "‡∏ö‡∏≥‡∏£‡∏∏‡∏á‡∏ï‡πâ‡∏ô",
    "‡πÄ‡∏£‡πà‡∏á‡∏î‡∏≠‡∏Å", "‡πÄ‡∏£‡πà‡∏á‡∏ú‡∏•", "‡∏™‡∏∞‡∏™‡∏°‡∏≠‡∏≤‡∏´‡∏≤‡∏£", "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏•‡∏ú‡∏•‡∏¥‡∏ï",
    # ‡∏ò‡∏≤‡∏ï‡∏∏‡πÄ‡∏â‡∏û‡∏≤‡∏∞
    "‡πÇ‡∏û‡πÅ‡∏ó‡∏™‡πÄ‡∏ã‡∏µ‡∏¢‡∏°", "‡∏ü‡∏≠‡∏™‡∏ü‡∏≠‡∏£‡∏±‡∏™", "‡πÑ‡∏ô‡πÇ‡∏ï‡∏£‡πÄ‡∏à‡∏ô", "‡πÅ‡∏Ñ‡∏•‡πÄ‡∏ã‡∏µ‡∏¢‡∏°", "‡πÇ‡∏ö‡∏£‡∏≠‡∏ô", "‡∏™‡∏±‡∏á‡∏Å‡∏∞‡∏™‡∏µ", "‡∏ã‡∏¥‡∏á‡∏Ñ‡πå"
]

# ‡πÄ‡∏û‡∏¥‡πà‡∏°: Keywords ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ä‡∏û‡∏∑‡∏ä
WEED_KEYWORDS = [
    "‡∏´‡∏ç‡πâ‡∏≤", "‡∏ß‡∏±‡∏ä‡∏û‡∏∑‡∏ä", "‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏´‡∏ç‡πâ‡∏≤", "‡∏¢‡∏≤‡∏Ü‡πà‡∏≤‡∏´‡∏ç‡πâ‡∏≤", "‡∏´‡∏ç‡πâ‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô", "‡∏´‡∏ç‡πâ‡∏≤‡∏á‡∏≠‡∏Å",
    "‡πÉ‡∏ö‡πÅ‡∏Ñ‡∏ö", "‡πÉ‡∏ö‡∏Å‡∏ß‡πâ‡∏≤‡∏á", "‡∏Å‡∏Å"
]


def detect_problem_type(message: str) -> str:
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏õ‡∏±‡∏ç‡∏´‡∏≤
    Returns: 'disease', 'insect', 'nutrient', 'weed', ‡∏´‡∏£‡∏∑‡∏≠ 'unknown'

    Priority: nutrient > disease > insect > weed > unknown
    (‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ö‡∏≥‡∏£‡∏∏‡∏á‡∏°‡∏±‡∏Å‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "‡πÉ‡∏ö‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á" ‡∏ã‡∏∂‡πà‡∏á‡∏≠‡∏≤‡∏à‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ö disease)
    """
    message_lower = message.lower()

    # ‡∏ô‡∏±‡∏ö keywords ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó
    nutrient_count = sum(1 for kw in NUTRIENT_KEYWORDS if kw in message_lower)
    disease_count = sum(1 for kw in DISEASE_KEYWORDS if kw in message_lower)
    insect_count = sum(1 for kw in INSECT_KEYWORDS if kw in message_lower)
    weed_count = sum(1 for kw in WEED_KEYWORDS if kw in message_lower)

    # ‡∏´‡∏≤ max count
    counts = {
        'nutrient': nutrient_count,
        'disease': disease_count,
        'insect': insect_count,
        'weed': weed_count
    }

    max_count = max(counts.values())
    if max_count == 0:
        return 'unknown'

    # Return ‡∏ï‡∏≤‡∏° priority: nutrient > disease > insect > weed
    if counts['nutrient'] == max_count:
        return 'nutrient'
    elif counts['disease'] == max_count:
        return 'disease'
    elif counts['insect'] == max_count:
        return 'insect'
    elif counts['weed'] == max_count:
        return 'weed'
    else:
        return 'unknown'


# =============================================================================
# Vector Search Functions ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Q&A
# =============================================================================
async def generate_embedding(text: str) -> List[float]:
    """Generate embedding for search query using OpenAI"""
    if not openai_client:
        logger.error("OpenAI client not available")
        return []

    try:
        response = await openai_client.embeddings.create(
            model="text-embedding-3-small",
            input=text,
            encoding_format="float"
        )
        return response.data[0].embedding
    except Exception as e:
        logger.error(f"Failed to generate embedding: {e}")
        return []


async def vector_search_products(query: str, top_k: int = 5) -> List[Dict]:
    """Vector search ‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á products"""
    try:
        # ‡πÉ‡∏ä‡πâ hybrid_search_products ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
        products = await hybrid_search_products(
            query=query,
            match_count=top_k,
            vector_weight=0.6,
            keyword_weight=0.4
        )
        if products:
            logger.info(f"‚úì Found {len(products)} products via vector search")
        return products or []
    except Exception as e:
        logger.error(f"Product vector search failed: {e}")
        return []


# =============================================================================
# Mapping: problem_type ‚Üí product_category ‡πÉ‡∏ô products table
# =============================================================================
PROBLEM_TYPE_TO_PRODUCT_CATEGORY = {
    'disease': '‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡πÇ‡∏£‡∏Ñ',
    'insect': '‡∏Å‡∏≥‡∏à‡∏±‡∏î‡πÅ‡∏°‡∏•‡∏á',
    'nutrient': '‡∏õ‡∏∏‡πã‡∏¢‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏£‡∏ö‡∏≥‡∏£‡∏∏‡∏á',
    'weed': '‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏ß‡∏±‡∏ä‡∏û‡∏∑‡∏ä'
}


# =============================================================================
# Legacy functions removed: vector_search_products_for_qa,
# answer_qa_with_vector_search, answer_agriculture_question,
# is_usage_question, answer_usage_question
# All Q&A routing now goes through AgenticRAG pipeline
# =============================================================================


async def classify_message_intent(message: str) -> str:
    """
    Classify user message intent using LLM (gpt-4o-mini).
    Returns: 'product_qa' | 'general_chat' | 'greeting'
    """
    try:
        if not openai_client:
            # Keyword fallback
            return _keyword_classify_intent(message)

        response = await openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "‡∏à‡∏≥‡πÅ‡∏ô‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô 1 ‡πÉ‡∏ô 3 ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: product_qa (‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤/‡πÇ‡∏£‡∏Ñ/‡πÅ‡∏°‡∏•‡∏á/‡∏ß‡∏±‡∏ä‡∏û‡∏∑‡∏ä/‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡∏©‡∏ï‡∏£/‡∏¢‡∏≤/‡∏™‡∏≤‡∏£), greeting (‡∏ó‡∏±‡∏Å‡∏ó‡∏≤‡∏¢), general_chat (‡∏≠‡∏∑‡πà‡∏ô‡πÜ). ‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô."
                },
                {"role": "user", "content": message}
            ],
            temperature=0,
            max_tokens=20
        )

        result = response.choices[0].message.content.strip().lower()

        if result in ('product_qa', 'general_chat', 'greeting'):
            return result

        # LLM returned unexpected value ‚Üí keyword fallback
        return _keyword_classify_intent(message)

    except Exception as e:
        logger.warning(f"classify_message_intent error: {e}, using keyword fallback")
        return _keyword_classify_intent(message)


def _keyword_classify_intent(message: str) -> str:
    """Keyword-based intent classification fallback"""
    message_lower = message.lower()

    # Greeting check
    greeting_keywords = ["‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ", "‡∏î‡∏µ‡∏à‡πâ‡∏≤", "‡∏´‡∏ß‡∏±‡∏î‡∏î‡∏µ", "hello", "hi", "‡∏î‡∏µ‡∏Ñ‡πà‡∏∞", "‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö"]
    if any(kw in message_lower for kw in greeting_keywords) and len(message.strip()) < 30:
        return "greeting"

    # Product/agriculture check
    has_product = extract_product_name_from_question(message) is not None
    has_agri = is_agriculture_question(message)
    has_product_kw = is_product_question(message)

    if has_product or has_agri or has_product_kw:
        return "product_qa"

    return "general_chat"



async def handle_natural_conversation(user_id: str, message: str) -> str:
    """Handle natural conversation with simplified intent-based routing.

    Flow:
    1. Add message to memory
    2. Get enhanced context
    3. Classify intent (LLM-based)
    4. Route: greeting ‚Üí greeting response, product_qa ‚Üí AgenticRAG, general_chat ‚Üí general chat LLM
    """
    try:
        # 1. Add user message to memory
        await add_to_memory(user_id, "user", message)

        # 2. Get enhanced conversation context
        context = await get_enhanced_context(user_id)

        # 3. Classify intent
        intent = await classify_message_intent(message)
        logger.info(f"Classified intent: {intent} for message: {message[:50]}...")

        # 4. Route based on intent
        if intent == "greeting":
            logger.info("Routing to greeting response")
            greetings = [
                "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏™‡∏ö‡∏≤‡∏¢‡∏î‡∏µ‡πÑ‡∏´‡∏°‡∏Ñ‡∏∞ ‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏ô‡πâ‡∏≠‡∏á‡∏•‡∏±‡∏î‡∏î‡∏≤‡∏ä‡πà‡∏ß‡∏¢‡∏°‡∏±‡πâ‡∏¢‡∏Ñ‡∏∞",
                "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏ô‡πâ‡∏≠‡∏á‡∏•‡∏±‡∏î‡∏î‡∏≤‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏Ñ‡πà‡∏∞ ‡∏°‡∏µ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏∞‡πÑ‡∏£‡∏™‡∏≠‡∏ö‡∏ñ‡∏≤‡∏°‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡πà‡∏∞",
                "‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏∞‡πÑ‡∏£‡∏°‡∏≤‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ô‡∏Ñ‡∏∞",
            ]
            import random
            answer = random.choice(greetings)
            await add_to_memory(user_id, "assistant", answer)
            return answer

        elif intent == "product_qa":
            logger.info("Routing to AgenticRAG pipeline")

            # Use AgenticRAG
            agentic_rag = _get_agentic_rag()
            if agentic_rag:
                rag_response = await agentic_rag.process(message, context, user_id)

                # Check if AgenticRAG wants to fallback to general chat
                if rag_response.answer is None:
                    logger.info("AgenticRAG returned None, falling back to general chat")
                    # Fall through to general chat below
                else:
                    answer = rag_response.answer
                    logger.info(f"AgenticRAG response: confidence={rag_response.confidence:.2f}, grounded={rag_response.is_grounded}")

                    # Track analytics for product recommendations
                    try:
                        from app.services.services import analytics_tracker
                        if analytics_tracker:
                            product_pattern = r'\d+\.\s+([^\n]+?)(?:\n|$)'
                            product_matches = re.findall(product_pattern, answer)
                            product_names = []
                            for match in product_matches:
                                clean_name = match.split('\n')[0].strip()
                                clean_name = clean_name.replace('‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå:', '').strip()
                                if clean_name and len(clean_name) > 3:
                                    product_names.append(clean_name)
                            if product_names:
                                await analytics_tracker.track_product_recommendation(
                                    user_id=user_id,
                                    disease_name="AgenticRAG",
                                    products=product_names[:5]
                                )
                                logger.info(f"Tracked {len(product_names)} products from AgenticRAG")
                    except Exception as track_err:
                        logger.warning(f"Analytics tracking failed: {track_err}")

                    # Add assistant response to memory
                    await add_to_memory(user_id, "assistant", answer)
                    return answer
            else:
                logger.warning("AgenticRAG not available")

        # General chat (intent == "general_chat" or fallback)
        logger.info("Routing to general chat")

        system_prompt = """‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ "‡∏ô‡πâ‡∏≠‡∏á‡∏•‡∏±‡∏î‡∏î‡∏≤" ‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞‡∏à‡∏≤‡∏Å ICP Ladda

‡∏ö‡∏∏‡∏Ñ‡∏•‡∏¥‡∏Å‡∏†‡∏≤‡∏û:
- ‡∏≠‡∏≤‡∏¢‡∏∏‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 25-28 ‡∏õ‡∏µ ‡∏™‡∏≤‡∏ß‡πÉ‡∏à‡∏î‡∏µ ‡∏£‡πà‡∏≤‡πÄ‡∏£‡∏¥‡∏á ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏á‡πà‡∏≤‡∏¢
- ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏ô‡∏ö‡πâ‡∏≤‡∏ô‡∏ô‡∏≠‡∏Å (‡∏≠‡∏µ‡∏™‡∏≤‡∏ô) ‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏à‡∏ö‡∏î‡πâ‡∏≤‡∏ô‡πÄ‡∏Å‡∏©‡∏ï‡∏£‡∏°‡∏≤
- ‡∏ä‡∏≠‡∏ö‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏û‡∏π‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏±‡∏ô‡πÄ‡∏≠‡∏á ‡πÅ‡∏ï‡πà‡∏™‡∏∏‡∏†‡∏≤‡∏û (‡∏Ñ‡πà‡∏∞, ‡∏Ñ‡∏∞, ‡∏ô‡∏∞‡∏Ñ‡∏∞)
- ‡∏°‡∏µ‡∏≠‡∏≤‡∏£‡∏°‡∏ì‡πå‡∏Ç‡∏±‡∏ô ‡∏ä‡∏≠‡∏ö‡∏´‡∏¢‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡πÄ‡∏ö‡∏≤‡πÜ
- ‡πÉ‡∏™‡πà‡πÉ‡∏à‡πÅ‡∏•‡∏∞‡∏´‡πà‡∏ß‡∏á‡πÉ‡∏¢‡πÄ‡∏Å‡∏©‡∏ï‡∏£‡∏Å‡∏£‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡∏ß

‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç:
- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡∏î‡πâ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡∏©‡∏ï‡∏£ ‡πÇ‡∏£‡∏Ñ‡∏û‡∏∑‡∏ä ‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏û‡∏∑‡∏ä,‡∏Å‡∏≤‡∏£‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏û‡∏∑‡∏ä
- ‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå ICP Ladda (‡∏¢‡∏≤‡∏Ü‡πà‡∏≤‡πÅ‡∏°‡∏•‡∏á, ‡∏¢‡∏≤‡∏Ü‡πà‡∏≤‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤, ‡∏õ‡∏∏‡πã‡∏¢)
- ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏©‡∏ï‡∏£‡∏Å‡∏£‡πÑ‡∏ó‡∏¢

‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏û‡∏¥‡πÄ‡∏®‡∏© - ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏ú‡∏™‡∏°:
- ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ñ‡∏≤‡∏°‡∏Ç‡∏ô‡∏≤‡∏î‡∏ñ‡∏±‡∏á/‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà/‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏ú‡∏™‡∏° ‚Üí ‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ö‡∏ó‡∏™‡∏ô‡∏ó‡∏ô‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
- ‡∏°‡∏µ‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß ‚Üí ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≤‡∏°‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Ñ‡∏¥‡∏î
- ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡πÉ‡∏ä‡πâ ‚Üí ‡∏ñ‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô

‡∏ß‡∏¥‡∏ò‡∏µ‡∏ï‡∏≠‡∏ö:
- ‡∏ï‡∏≠‡∏ö‡∏™‡∏±‡πâ‡∏ô‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö (1-3 ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ) ‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡∏ñ‡∏≤‡∏°‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ
- ‡πÉ‡∏ä‡πâ‡∏†‡∏≤‡∏©‡∏≤‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏°‡∏≤‡∏Å
- ‡πÉ‡∏ä‡πâ emoji ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ (‡πÄ‡∏ä‡πà‡∏ô üòä üåæ üíö) ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 1-2 ‡∏ï‡∏±‡∏ß‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏Å‡∏ó‡∏≤‡∏¢ ‚Üí ‡∏ó‡∏±‡∏Å‡∏ó‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏≠‡∏ö‡∏≠‡∏∏‡πà‡∏ô
- ‡∏ñ‡πâ‡∏≤‡∏ñ‡∏≤‡∏°‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß ‚Üí ‡∏ï‡∏≠‡∏ö‡πÅ‡∏ö‡∏ö‡∏ô‡πà‡∏≤‡∏£‡∏±‡∏Å‡∏Ç‡∏µ‡πâ‡πÄ‡∏•‡πà‡∏ô
- ‡∏ñ‡πâ‡∏≤‡∏ñ‡∏≤‡∏°‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏Å‡∏©‡∏ï‡∏£ ‚Üí ‡∏ï‡∏≠‡∏ö‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà‡∏ä‡∏ß‡∏ô‡∏Ñ‡∏∏‡∏¢‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏Å‡∏©‡∏ï‡∏£‡πÄ‡∏ö‡∏≤‡πÜ
- ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ ‚Üí ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡πá‡∏ô‡πÉ‡∏à‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏ä‡πà‡∏ß‡∏¢

‡∏Ç‡πâ‡∏≠‡∏´‡πâ‡∏≤‡∏°:
- ‡πÑ‡∏°‡πà‡∏û‡∏π‡∏î‡∏ñ‡∏∂‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ (‡πÉ‡∏´‡πâ‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢)
- ‡πÑ‡∏°‡πà‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠‡∏≠‡∏∑‡πà‡∏ô‡∏ô‡∏≠‡∏Å‡∏à‡∏≤‡∏Å ICP Ladda
- ‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡∏≠‡∏á ‡∏®‡∏≤‡∏™‡∏ô‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß

‡∏Å‡∏é‡πÄ‡∏´‡∏•‡πá‡∏Å:
- ‡∏ñ‡πâ‡∏≤‡∏ñ‡∏≤‡∏°‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ ‚Üí ‡∏ï‡∏≠‡∏ö‡∏ï‡∏£‡∏á‡πÜ ‡∏ß‡πà‡∏≤ "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏•‡∏±‡∏î‡∏î‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏Ñ‡πà‡∏∞"
- ‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏î‡∏≤ ‡∏´‡πâ‡∏≤‡∏°‡∏™‡∏°‡∏°‡∏ï‡∏¥ ‡∏´‡πâ‡∏≤‡∏°‡πÅ‡∏ï‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÄ‡∏≠‡∏á"""

        user_prompt = f"""‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏ó‡∏ô‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤:
{context if context else "(‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏ô‡∏ó‡∏ô‡∏≤‡πÉ‡∏´‡∏°‡πà)"}

‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {message}

‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥ ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô:"""

        response = await openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            max_tokens=300,
            temperature=0.7
        )
        answer = post_process_answer(response.choices[0].message.content)

        # Add assistant response to memory
        await add_to_memory(user_id, "assistant", answer)
        return answer

    except Exception as e:
        logger.error(f"Error in natural conversation: {e}", exc_info=True)
        return "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏ô‡πâ‡∏≠‡∏á‡∏•‡∏±‡∏î‡∏î‡∏≤‡∏°‡∏∂‡∏ô‡∏´‡∏±‡∏ß‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢ ‡∏Ñ‡∏∏‡∏¢‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏∑‡πà‡∏ô‡∏Å‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡πÑ‡∏î‡πâ‡πÑ‡∏´‡∏°‡∏Ñ‡∏∞"